
BLE_GW_PP_Device.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  000003de  00000492  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003de  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000031  00800126  00800126  000004b8  2**0
                  ALLOC
  3 .fuse         00000003  00820000  00820000  000004b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  000004bb  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004ec  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000000d8  00000000  00000000  0000052c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000007d0  00000000  00000000  00000604  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000002b9  00000000  00000000  00000dd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000723  00000000  00000000  0000108d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000150  00000000  00000000  000017b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002b6  00000000  00000000  00001900  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000092  00000000  00000000  00001bb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000088  00000000  00000000  00001c48  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__vector_18>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	11 e0       	ldi	r17, 0x01	; 1
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	ee ed       	ldi	r30, 0xDE	; 222
  c8:	f3 e0       	ldi	r31, 0x03	; 3
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a6 32       	cpi	r26, 0x26	; 38
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
  d6:	21 e0       	ldi	r18, 0x01	; 1
  d8:	a6 e2       	ldi	r26, 0x26	; 38
  da:	b1 e0       	ldi	r27, 0x01	; 1
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	a7 35       	cpi	r26, 0x57	; 87
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 a0 00 	call	0x140	; 0x140 <main>
  ea:	0c 94 ed 01 	jmp	0x3da	; 0x3da <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <ADC_Init>:
void ADC_Init( void )
{
	// Reference on VACC.
	// Data right align.
	// ADC7.
	ADMUX = 0x67;
  f2:	87 e6       	ldi	r24, 0x67	; 103
  f4:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	// Power reduction ADC off, for ADC.
	PRR0 &= 0xfe;
  f8:	e4 e6       	ldi	r30, 0x64	; 100
  fa:	f0 e0       	ldi	r31, 0x00	; 0
  fc:	80 81       	ld	r24, Z
  fe:	8e 7f       	andi	r24, 0xFE	; 254
 100:	80 83       	st	Z, r24
	// Single conversion ( no auto trigger ). 
	// Clock division 128.
	ADCSRA = 0x97;
 102:	ea e7       	ldi	r30, 0x7A	; 122
 104:	f0 e0       	ldi	r31, 0x00	; 0
 106:	87 e9       	ldi	r24, 0x97	; 151
 108:	80 83       	st	Z, r24
	// Start conversion.
	ADCSRA |= 0x40;	
 10a:	80 81       	ld	r24, Z
 10c:	80 64       	ori	r24, 0x40	; 64
 10e:	80 83       	st	Z, r24
 110:	08 95       	ret

00000112 <ADC_Task>:

// ADC task.
void ADC_Task( void )
{
	// ADC interrupt flag bit check.
	temp1 = ADCSRA;
 112:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	temp1 &= 0x10;
 116:	80 71       	andi	r24, 0x10	; 16
 118:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
	if( temp1 == 0 ){
 11c:	88 23       	and	r24, r24
 11e:	61 f0       	breq	.+24     	; 0x138 <ADC_Task+0x26>
		return;
	}
	// Clear flag bit.
	ADCSRA |= 0x10;
 120:	ea e7       	ldi	r30, 0x7A	; 122
 122:	f0 e0       	ldi	r31, 0x00	; 0
 124:	80 81       	ld	r24, Z
 126:	80 61       	ori	r24, 0x10	; 16
 128:	80 83       	st	Z, r24
	// Keep ADC value.
	adc_value = ADCH;	
 12a:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 12e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <adc_value>
	// Start conversion.
	ADCSRA |= 0x40;	
 132:	80 81       	ld	r24, Z
 134:	80 64       	ori	r24, 0x40	; 64
 136:	80 83       	st	Z, r24
 138:	08 95       	ret

0000013a <GPIO_Init>:

// GPIO initialize.
void GPIO_Init( void )
{
	// PORT B bit #1, outport.
	DDRB |= 0x02;
 13a:	21 9a       	sbi	0x04, 1	; 4
	// PB1 output low.
	PORTB &= 0xfd;
 13c:	29 98       	cbi	0x05, 1	; 5
 13e:	08 95       	ret

00000140 <main>:
};

int main(void)
{
	// System clock prescaler 1.
	CLKPR = 0x80;  // Enable.
 140:	e1 e6       	ldi	r30, 0x61	; 97
 142:	f0 e0       	ldi	r31, 0x00	; 0
 144:	80 e8       	ldi	r24, 0x80	; 128
 146:	80 83       	st	Z, r24
	CLKPR = 0x00;  // Write value.
 148:	10 82       	st	Z, r1
	
	// GPIO initialize.
	GPIO_Init();
 14a:	0e 94 9d 00 	call	0x13a	; 0x13a <GPIO_Init>
	// Timer #0 initialize.
	Timer0_Init();
 14e:	0e 94 b7 00 	call	0x16e	; 0x16e <Timer0_Init>
	// UART #0 initialize.
	UART0_Init();
 152:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <UART0_Init>
	// ADC initialize.
	ADC_Init();
 156:	0e 94 79 00 	call	0xf2	; 0xf2 <ADC_Init>
	
	// Enable global interrupt.
	sei();
 15a:	78 94       	sei
		
    /* Replace with your application code */
    while (1){
		
		// Timer task.
		Timer0_Task();
 15c:	0e 94 be 00 	call	0x17c	; 0x17c <Timer0_Task>
		// ADC task.
		ADC_Task();
 160:	0e 94 89 00 	call	0x112	; 0x112 <ADC_Task>
		// UART received data check.
		UART0_Rec_Check();
 164:	0e 94 91 01 	call	0x322	; 0x322 <UART0_Rec_Check>
		// UART transmit task.
		UART0_Trn_Task();
 168:	0e 94 10 01 	call	0x220	; 0x220 <UART0_Trn_Task>
    }
 16c:	f7 cf       	rjmp	.-18     	; 0x15c <main+0x1c>

0000016e <Timer0_Init>:
{
	// 8MHz oscillator, 0.125us * 1024 = 128us.
	// period, 128us * 256 = 32.768 ms.	
	
	// CTC mode, no output.
	TCCR0A = 0x02;
 16e:	82 e0       	ldi	r24, 0x02	; 2
 170:	84 bd       	out	0x24, r24	; 36
	// Prescaler 1024.
	TCCR0B = 0x05; 
 172:	85 e0       	ldi	r24, 0x05	; 5
 174:	85 bd       	out	0x25, r24	; 37
	// comparator A.
	// - 10ms / 256us = 38.
	OCR0A = 39;
 176:	87 e2       	ldi	r24, 0x27	; 39
 178:	87 bd       	out	0x27, r24	; 39
 17a:	08 95       	ret

0000017c <Timer0_Task>:

// Timer #0 task.
void Timer0_Task( void )
{
	// Check interrupt flag bit. 
	temp1 = TIFR0;
 17c:	85 b3       	in	r24, 0x15	; 21
	temp1 &= 0x02;
 17e:	82 70       	andi	r24, 0x02	; 2
 180:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
	if( temp1 == 0 ){
 184:	88 23       	and	r24, r24
 186:	89 f0       	breq	.+34     	; 0x1aa <Timer0_Task+0x2e>
		return;
	}
	// About 10ms past.
	// Clear flag bit.
	TIFR0 |= 0x02;	
 188:	a9 9a       	sbi	0x15, 1	; 21
	// UART #0 received time out.
	if( uart0_rec_cnt ){
 18a:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <uart0_rec_cnt>
 18e:	88 23       	and	r24, r24
 190:	61 f0       	breq	.+24     	; 0x1aa <Timer0_Task+0x2e>
		++uart0_rec_to;
 192:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uart0_rec_to>
 196:	8f 5f       	subi	r24, 0xFF	; 255
		if( uart0_rec_to == 20 ){
 198:	84 31       	cpi	r24, 0x14	; 20
 19a:	19 f0       	breq	.+6      	; 0x1a2 <Timer0_Task+0x26>
	// About 10ms past.
	// Clear flag bit.
	TIFR0 |= 0x02;	
	// UART #0 received time out.
	if( uart0_rec_cnt ){
		++uart0_rec_to;
 19c:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <uart0_rec_to>
 1a0:	08 95       	ret
		if( uart0_rec_to == 20 ){
			uart0_rec_to = 0;
 1a2:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <uart0_rec_to>
			uart0_rec_cnt = 0;
 1a6:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <uart0_rec_cnt>
 1aa:	08 95       	ret

000001ac <__vector_18>:
								 ','};


// UART #0 received ISR.
ISR( USART0_RX_vect )
{
 1ac:	1f 92       	push	r1
 1ae:	0f 92       	push	r0
 1b0:	0f b6       	in	r0, 0x3f	; 63
 1b2:	0f 92       	push	r0
 1b4:	11 24       	eor	r1, r1
 1b6:	8f 93       	push	r24
 1b8:	9f 93       	push	r25
 1ba:	ef 93       	push	r30
 1bc:	ff 93       	push	r31
	// Clear received time out.
	uart0_rec_to = 0;
 1be:	10 92 56 01 	sts	0x0156, r1	; 0x800156 <uart0_rec_to>
	// Hold received data.		
	uart0_rec_data[uart0_rec_cnt] = UDR0;
 1c2:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <uart0_rec_cnt>
 1c6:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 1ca:	e8 2f       	mov	r30, r24
 1cc:	f0 e0       	ldi	r31, 0x00	; 0
 1ce:	e7 5d       	subi	r30, 0xD7	; 215
 1d0:	fe 4f       	sbci	r31, 0xFE	; 254
 1d2:	90 83       	st	Z, r25
	if( uart0_rec_cnt < 16 ){
 1d4:	80 31       	cpi	r24, 0x10	; 16
 1d6:	18 f4       	brcc	.+6      	; 0x1de <__vector_18+0x32>
		++uart0_rec_cnt;
 1d8:	8f 5f       	subi	r24, 0xFF	; 255
 1da:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <uart0_rec_cnt>
	} 
}
 1de:	ff 91       	pop	r31
 1e0:	ef 91       	pop	r30
 1e2:	9f 91       	pop	r25
 1e4:	8f 91       	pop	r24
 1e6:	0f 90       	pop	r0
 1e8:	0f be       	out	0x3f, r0	; 63
 1ea:	0f 90       	pop	r0
 1ec:	1f 90       	pop	r1
 1ee:	18 95       	reti

000001f0 <UART0_Init>:

// UART #0 initialize.
void UART0_Init( void )
{
	// 9600 bps @ 8MHz.
	UBRR0H = 0;
 1f0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = 51;
 1f4:	83 e3       	ldi	r24, 0x33	; 51
 1f6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	// RX interrupt enable.
	// RX enable.
	// TX enable.
	// 8 bit data.
	// No parity.
	UCSR0B = 0x98;
 1fa:	88 e9       	ldi	r24, 0x98	; 152
 1fc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	// Variable reset.
	rn4020_char_value[0] = 0x30;
 200:	ee e3       	ldi	r30, 0x3E	; 62
 202:	f1 e0       	ldi	r31, 0x01	; 1
 204:	80 e3       	ldi	r24, 0x30	; 48
 206:	80 83       	st	Z, r24
	rn4020_char_value[1] = 0x30;
 208:	81 83       	std	Z+1, r24	; 0x01
	rn4020_char_value[2] = 0x30;
 20a:	82 83       	std	Z+2, r24	; 0x02
	rn4020_char_value[3] = 0x30;
 20c:	83 83       	std	Z+3, r24	; 0x03
	rn4020_char_value[4] = 0x0d;
 20e:	8d e0       	ldi	r24, 0x0D	; 13
 210:	84 83       	std	Z+4, r24	; 0x04
	rn4020_char_value[5] = 0x0a;
 212:	8a e0       	ldi	r24, 0x0A	; 10
 214:	85 83       	std	Z+5, r24	; 0x05
	
	uart0_trn_cnt = 0;
 216:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <uart0_trn_cnt>
	uart0_trn_task = 0;	
 21a:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <uart0_trn_task>
 21e:	08 95       	ret

00000220 <UART0_Trn_Task>:

// UART #0 transmit task.
void UART0_Trn_Task( void )
{
	// Check data counter.
	if( uart0_trn_cnt == 0 ){
 220:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <uart0_trn_cnt>
 224:	81 11       	cpse	r24, r1
 226:	2e c0       	rjmp	.+92     	; 0x284 <UART0_Trn_Task+0x64>
		// Task #3, send command.
		if( uart0_trn_task == 3 ){			
 228:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <uart0_trn_task>
 22c:	83 30       	cpi	r24, 0x03	; 3
 22e:	69 f4       	brne	.+26     	; 0x24a <UART0_Trn_Task+0x2a>
			puart0_trn_data = rn4020_cmd;
 230:	81 e2       	ldi	r24, 0x21	; 33
 232:	91 e0       	ldi	r25, 0x01	; 1
 234:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__data_end+0x1>
 238:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
			uart0_trn_cnt = 4;
 23c:	84 e0       	ldi	r24, 0x04	; 4
 23e:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uart0_trn_cnt>
			--uart0_trn_task;
 242:	82 e0       	ldi	r24, 0x02	; 2
 244:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uart0_trn_task>
 248:	08 95       	ret
		}
		// Task #2, send UUID128.
		else if( uart0_trn_task == 2 ){
 24a:	82 30       	cpi	r24, 0x02	; 2
 24c:	69 f4       	brne	.+26     	; 0x268 <UART0_Trn_Task+0x48>
			puart0_trn_data = rn4020_uuid;
 24e:	80 e0       	ldi	r24, 0x00	; 0
 250:	91 e0       	ldi	r25, 0x01	; 1
 252:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__data_end+0x1>
 256:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
			uart0_trn_cnt = 33;
 25a:	81 e2       	ldi	r24, 0x21	; 33
 25c:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uart0_trn_cnt>
			--uart0_trn_task;			
 260:	81 e0       	ldi	r24, 0x01	; 1
 262:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uart0_trn_task>
 266:	08 95       	ret
		}
		// Task #3, send characteristic value.
		else if( uart0_trn_task == 1 ){
 268:	81 30       	cpi	r24, 0x01	; 1
 26a:	41 f5       	brne	.+80     	; 0x2bc <UART0_Trn_Task+0x9c>
			puart0_trn_data = rn4020_char_value;
 26c:	8e e3       	ldi	r24, 0x3E	; 62
 26e:	91 e0       	ldi	r25, 0x01	; 1
 270:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__data_end+0x1>
 274:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
			uart0_trn_cnt = 6;
 278:	86 e0       	ldi	r24, 0x06	; 6
 27a:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uart0_trn_cnt>
			--uart0_trn_task;			
 27e:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <uart0_trn_task>
 282:	08 95       	ret
		}
		return;
	}
	// Check transmit buffer.
	temp1 = UCSR0A;
 284:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	temp1 &= 0x20;
 288:	80 72       	andi	r24, 0x20	; 32
 28a:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
	if( temp1 == 0 ){
 28e:	88 23       	and	r24, r24
 290:	a9 f0       	breq	.+42     	; 0x2bc <UART0_Trn_Task+0x9c>
		return;
	}
	// Data out.
	UDR0 = *puart0_trn_data;
 292:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
 296:	f0 91 27 01 	lds	r31, 0x0127	; 0x800127 <__data_end+0x1>
 29a:	80 81       	ld	r24, Z
 29c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	// Next data.
	++puart0_trn_data;
 2a0:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
 2a4:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <__data_end+0x1>
 2a8:	01 96       	adiw	r24, 0x01	; 1
 2aa:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__data_end+0x1>
 2ae:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
	--uart0_trn_cnt;
 2b2:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <uart0_trn_cnt>
 2b6:	81 50       	subi	r24, 0x01	; 1
 2b8:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uart0_trn_cnt>
 2bc:	08 95       	ret

000002be <ToValue>:
}

// Character to value.
void ToValue( void )
{
	temp1 = temp2;
 2be:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <temp2>
	temp1 &= 0xf0;
 2c2:	98 2f       	mov	r25, r24
 2c4:	90 7f       	andi	r25, 0xF0	; 240
	
	// '0' ~ '9'.
	if( temp1 == 0x30 ){
 2c6:	90 33       	cpi	r25, 0x30	; 48
 2c8:	31 f4       	brne	.+12     	; 0x2d6 <ToValue+0x18>
		temp1 = temp2;
		temp1 &= 0x0f;
 2ca:	8f 70       	andi	r24, 0x0F	; 15
 2cc:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
		if( temp1 < 10 ){
 2d0:	8a 30       	cpi	r24, 0x0A	; 10
 2d2:	b8 f4       	brcc	.+46     	; 0x302 <ToValue+0x44>
 2d4:	08 95       	ret
			return;
		}
	}
	// 'A' ~ 'F'.
	else if( temp1 == 0x40 ){
 2d6:	90 34       	cpi	r25, 0x40	; 64
 2d8:	49 f4       	brne	.+18     	; 0x2ec <ToValue+0x2e>
		temp1 = temp2;
		temp1 &= 0x0f;
 2da:	8f 70       	andi	r24, 0x0F	; 15
		if( temp1 > 0 && temp1 < 7 ){
 2dc:	9f ef       	ldi	r25, 0xFF	; 255
 2de:	98 0f       	add	r25, r24
 2e0:	96 30       	cpi	r25, 0x06	; 6
 2e2:	78 f4       	brcc	.+30     	; 0x302 <ToValue+0x44>
			temp1 += 10;
			--temp1;
 2e4:	87 5f       	subi	r24, 0xF7	; 247
 2e6:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
			return;
 2ea:	08 95       	ret
		}
	}
	// 'a' ~ 'f'.
	else if( temp1 == 0x60 ){
 2ec:	90 36       	cpi	r25, 0x60	; 96
 2ee:	49 f4       	brne	.+18     	; 0x302 <ToValue+0x44>
		temp1 = temp2;
		temp1 &= 0x0f;
 2f0:	8f 70       	andi	r24, 0x0F	; 15
		if( temp1 > 0 && temp1 < 7 ){
 2f2:	9f ef       	ldi	r25, 0xFF	; 255
 2f4:	98 0f       	add	r25, r24
 2f6:	96 30       	cpi	r25, 0x06	; 6
 2f8:	20 f4       	brcc	.+8      	; 0x302 <ToValue+0x44>
			temp1 += 10;
			--temp1;
 2fa:	87 5f       	subi	r24, 0xF7	; 247
 2fc:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
			return;
 300:	08 95       	ret
		}
	}
	// Others.
	// Input error.	
	temp1 = 0x10;
 302:	80 e1       	ldi	r24, 0x10	; 16
 304:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
 308:	08 95       	ret

0000030a <ToChar>:

// Value to character.
void ToChar( void )
{
	// 0 ~ 9.
	if( temp1 < 10 ){
 30a:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <temp1>
 30e:	8a 30       	cpi	r24, 0x0A	; 10
 310:	20 f4       	brcc	.+8      	; 0x31a <ToChar+0x10>
		temp1 += 0x30;
 312:	80 5d       	subi	r24, 0xD0	; 208
 314:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
		return;
 318:	08 95       	ret
	}
	// a ~ f.
	temp1 -= 10;
	temp1 += 0x61;	
 31a:	89 5a       	subi	r24, 0xA9	; 169
 31c:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
 320:	08 95       	ret

00000322 <UART0_Rec_Check>:
	--uart0_trn_cnt;
}

// UART #0 received check.
void UART0_Rec_Check( void )
{
 322:	cf 93       	push	r28
 324:	df 93       	push	r29
	// Check received count.
	if( uart0_rec_cnt < 15 ){
 326:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <uart0_rec_cnt>
 32a:	8f 30       	cpi	r24, 0x0F	; 15
 32c:	08 f4       	brcc	.+2      	; 0x330 <UART0_Rec_Check+0xe>
 32e:	52 c0       	rjmp	.+164    	; 0x3d4 <UART0_Rec_Check+0xb2>
		return;
	}
	// Clear received count.
	uart0_rec_cnt = 0;
 330:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <uart0_rec_cnt>
	// Check end character, '\n'.
	if( uart0_rec_data[14] != 0x0a ){
 334:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uart0_rec_data+0xe>
 338:	8a 30       	cpi	r24, 0x0A	; 10
 33a:	09 f0       	breq	.+2      	; 0x33e <UART0_Rec_Check+0x1c>
 33c:	4b c0       	rjmp	.+150    	; 0x3d4 <UART0_Rec_Check+0xb2>
		return;
	}
	// Check end character, '\r'.
	if( uart0_rec_data[13] != 0x0d ){
 33e:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uart0_rec_data+0xd>
 342:	8d 30       	cpi	r24, 0x0D	; 13
 344:	09 f0       	breq	.+2      	; 0x348 <UART0_Rec_Check+0x26>
 346:	46 c0       	rjmp	.+140    	; 0x3d4 <UART0_Rec_Check+0xb2>
		return;
	}
	// Check end character '.'.
	if( uart0_rec_data[12] != '.' ){
 348:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <uart0_rec_data+0xc>
 34c:	8e 32       	cpi	r24, 0x2E	; 46
 34e:	09 f0       	breq	.+2      	; 0x352 <UART0_Rec_Check+0x30>
 350:	41 c0       	rjmp	.+130    	; 0x3d4 <UART0_Rec_Check+0xb2>
		return;
	}
	// Get input control/value.
	temp2 = uart0_rec_data[10];
 352:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <uart0_rec_data+0xa>
 356:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <temp2>
	ToValue();
 35a:	0e 94 5f 01 	call	0x2be	; 0x2be <ToValue>
	if( temp1 == 0x10 ){
 35e:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <temp1>
 362:	80 31       	cpi	r24, 0x10	; 16
 364:	b9 f1       	breq	.+110    	; 0x3d4 <UART0_Rec_Check+0xb2>
		return;
	}
	chk_value = temp1;
	chk_value <<= 4;
 366:	82 95       	swap	r24
 368:	80 7f       	andi	r24, 0xF0	; 240
 36a:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <chk_value>
	
	temp2 = uart0_rec_data[11];
 36e:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uart0_rec_data+0xb>
 372:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <temp2>
	ToValue();
 376:	0e 94 5f 01 	call	0x2be	; 0x2be <ToValue>
	if( temp1 == 0x10 ){
 37a:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <temp1>
 37e:	90 31       	cpi	r25, 0x10	; 16
 380:	49 f1       	breq	.+82     	; 0x3d4 <UART0_Rec_Check+0xb2>
		return;
	}
	chk_value |= temp1;
 382:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <chk_value>
 386:	89 2b       	or	r24, r25
 388:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <chk_value>
	
	if( chk_value == 0 ){
 38c:	81 11       	cpse	r24, r1
 38e:	02 c0       	rjmp	.+4      	; 0x394 <UART0_Rec_Check+0x72>
		// LED off.
		PORTB &= 0xfd;
 390:	29 98       	cbi	0x05, 1	; 5
 392:	20 c0       	rjmp	.+64     	; 0x3d4 <UART0_Rec_Check+0xb2>
	}
	else if( chk_value == 0x01 ){
 394:	81 30       	cpi	r24, 0x01	; 1
 396:	11 f4       	brne	.+4      	; 0x39c <UART0_Rec_Check+0x7a>
		// LED on.
		PORTB |= 0x02;
 398:	29 9a       	sbi	0x05, 1	; 5
 39a:	1c c0       	rjmp	.+56     	; 0x3d4 <UART0_Rec_Check+0xb2>
	}
	else if( chk_value == 0x02 ){
 39c:	82 30       	cpi	r24, 0x02	; 2
 39e:	d1 f4       	brne	.+52     	; 0x3d4 <UART0_Rec_Check+0xb2>
		// Update characteristic value for remote read.
		temp1 = adc_value;
		temp1 >>= 4;
 3a0:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <adc_value>
 3a4:	82 95       	swap	r24
 3a6:	8f 70       	andi	r24, 0x0F	; 15
 3a8:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
		ToChar();	
 3ac:	0e 94 85 01 	call	0x30a	; 0x30a <ToChar>
		rn4020_char_value[2] = temp1;
 3b0:	ce e3       	ldi	r28, 0x3E	; 62
 3b2:	d1 e0       	ldi	r29, 0x01	; 1
 3b4:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <temp1>
 3b8:	8a 83       	std	Y+2, r24	; 0x02
		temp1 = adc_value;
		temp1 &= 0x0f;
 3ba:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <adc_value>
 3be:	8f 70       	andi	r24, 0x0F	; 15
 3c0:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <temp1>
		ToChar();
 3c4:	0e 94 85 01 	call	0x30a	; 0x30a <ToChar>
		rn4020_char_value[3] = temp1;
 3c8:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <temp1>
 3cc:	8b 83       	std	Y+3, r24	; 0x03
		// Set task count.
		uart0_trn_task = 3;		
 3ce:	83 e0       	ldi	r24, 0x03	; 3
 3d0:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <uart0_trn_task>
	}
}
 3d4:	df 91       	pop	r29
 3d6:	cf 91       	pop	r28
 3d8:	08 95       	ret

000003da <_exit>:
 3da:	f8 94       	cli

000003dc <__stop_program>:
 3dc:	ff cf       	rjmp	.-2      	; 0x3dc <__stop_program>
